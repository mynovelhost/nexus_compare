<?xml version="1.0" encoding="UTF-8" ?>
<!--

    Sonatype Nexus (TM) Open Source Version
    Copyright (c) 2008-present Sonatype, Inc.
    All rights reserved. Includes the third-party code listed at http://links.sonatype.com/products/nexus/oss/attributions.

    This program and the accompanying materials are made available under the terms of the Eclipse Public License Version 1.0,
    which accompanies this distribution and is available at http://www.eclipse.org/legal/epl-v10.html.

    Sonatype Nexus (TM) Professional Version is available from Sonatype, Inc. "Sonatype" and "Sonatype Nexus" are trademarks
    of Sonatype, Inc. Apache Maven is a trademark of the Apache Software Foundation. M2eclipse is a trademark of the
    Eclipse Foundation. All other trademarks are the property of their respective owners.

-->
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="${namespace}">

  <insert id="createSchema">
    --
    -- each format has a browse node table
    --
    CREATE TABLE IF NOT EXISTS ${format}_browse_node (
      browse_node_id  INT GENERATED BY DEFAULT AS IDENTITY,
      repository_id INT NOT NULL,
      format VARCHAR NOT NULL,
      path VARCHAR NOT NULL,
      name VARCHAR NOT NULL,
      parent_id INT NULL,
      component_id INT NULL,
      asset_id INT NULL,

      CONSTRAINT pk_${format}_browse_node_id PRIMARY KEY (browse_node_id),
      CONSTRAINT uk_${format}_browse_node_asset UNIQUE (asset_id),
      CONSTRAINT uk_${format}_browse_node_component UNIQUE (component_id),
      CONSTRAINT uk_${format}_browse_node_repository_path UNIQUE (repository_id, path),

      CONSTRAINT fk_${format}_browse_node_component_id FOREIGN KEY (component_id)
         REFERENCES ${format}_component (component_id),
      CONSTRAINT fk_${format}_browse_node_asset_id FOREIGN KEY (asset_id)
         REFERENCES ${format}_asset (asset_id),
      CONSTRAINT fk_${format}_browse_node_parent_id FOREIGN KEY (parent_id)
         REFERENCES ${format}_browse_node (browse_node_id)
    );
    --
  </insert>

  <sql id="browseNodeMatch">
    repository_id = #{repository.repositoryId}
    AND path = #{path}
  </sql>

  <sql id="isParent">
    EXISTS (SELECT 1
                  FROM ${format}_browse_node N
                 WHERE B.browse_node_id = N.parent_id)
  </sql>

  <sql id="isLeaf">
    NOT <include refid="isParent"/>
  </sql>
  
  <select id="assetNodeExists" resultType="boolean">
    SELECT count(browse_node_id) > 0
      FROM ${format}_browse_node
     WHERE asset_id = #{asset.assetId};
  </select>

  <select id="findBrowseNodeByAssetId" resultMap="datastoreBrowseNode">
    SELECT *
      FROM ${format}_browse_node
     WHERE asset_id = #{asset.assetId};
  </select>

  <select id="findBrowseNodeByComponentId" resultMap="datastoreBrowseNode">
    SELECT *
      FROM ${format}_browse_node
     WHERE component_id = #{component.componentId};
  </select>

  <select id="findDeepestNode" resultMap="datastoreBrowseNode">
    SELECT *
      FROM ${format}_browse_node
     WHERE repository_id = #{repository.repositoryId}
       AND path = ANY(#{paths})
     ORDER BY CHAR_LENGTH(path) DESC LIMIT 1;
  </select>

  <select id="getParentBrowseNodeId" resultType="Integer">
    SELECT parent_id
      FROM ${format}_browse_node
     WHERE browse_node_id = #{browseNodeId};
  </select>

  <select id="findPath" resultMap="datastoreBrowseNode">
    SELECT *
      FROM ${format}_browse_node
     WHERE <include refid="browseNodeMatch"/>;
  </select>

  <insert id="createNode" useGeneratedKeys="true" keyColumn="browse_node_id" keyProperty="node.id">
    INSERT INTO ${format}_browse_node (repository_id, format, parent_id, path, name)
    VALUES (#{repository.repositoryId}, #{node.format}, #{node.parentId}, #{node.path}, #{node.name});
  </insert>

  <insert id="createNode" useGeneratedKeys="true" keyColumn="browse_node_id" keyProperty="node.id" databaseId="PostgreSQL">
    INSERT INTO ${format}_browse_node (repository_id, format, parent_id, path, name)
    VALUES (#{repository.repositoryId}, #{node.format}, #{node.parentId}, #{node.path}, #{node.name})
           ON CONFLICT ON CONSTRAINT uk_${format}_browse_node_repository_path
           DO UPDATE SET name = #{node.name} RETURNING browse_node_id;
  </insert>

  <update id="linkAsset">
    UPDATE ${format}_browse_node
       SET asset_id = #{asset.assetId}
     WHERE browse_node_id = #{nodeId};
  </update>

  <update id="linkComponent">
    UPDATE ${format}_browse_node
       SET component_id = #{component.componentId}
     WHERE browse_node_id = #{nodeId};
  </update>

  <update id="unlinkAsset">
    UPDATE ${format}_browse_node B
       SET asset_id = null
     WHERE asset_id = #{asset.assetId}
       AND (component_id IS NOT NULL
            OR <include refid="isParent"/>);
  </update>

  <update id="unlinkComponent">
    UPDATE ${format}_browse_node B
       SET component_id = null
     WHERE component_id = #{component.componentId}
       AND (asset_id IS NOT NULL
            OR <include refid="isParent"/>);
  </update>

  <delete id="maybeDeleteNode">
    DELETE FROM ${format}_browse_node B
     WHERE <include refid="browseNodeMatch"/>
       AND <include refid="isLeaf"/>;
  </delete>

  <delete id="maybeDeleteAssetNode">
    DELETE FROM ${format}_browse_node B
     WHERE #{asset.assetId} IS NOT NULL
       AND asset_id = #{asset.assetId}
       AND component_id IS NULL
       AND <include refid="isLeaf"/>;
  </delete>

  <delete id="maybeDeleteComponentNode">
    DELETE FROM ${format}_browse_node B
     WHERE #{component.componentId} IS NOT NULL
       AND component_id = #{component.componentId}
       AND asset_id IS NULL
       AND <include refid="isLeaf"/>;
  </delete>

  <delete id="deleteBrowseNode">
    DELETE FROM ${format}_browse_node B
     WHERE B.browse_node_id = #{browseNodeId}
       AND <include refid="isLeaf"/>;
  </delete>

  <delete id="deleteRepository">
    DELETE FROM ${format}_browse_node B
     WHERE B.repository_id = #{repository.repositoryId}
       AND <include refid="isLeaf"/>
     LIMIT #{maxNodes};
  </delete>

  <delete id="deleteRepository" databaseId="PostgreSQL">
    -- PostgreSQL doesn't allow a LIMIT clause on DELETE
    DELETE FROM ${format}_browse_node
     WHERE browse_node_id = any(array(SELECT browse_node_id
                                        FROM ${format}_browse_node B
                                       WHERE B.repository_id = #{repository.repositoryId}
                                         AND <include refid="isLeaf"/>
                                       LIMIT #{maxNodes}));
  </delete>

  <resultMap id="datastoreBrowseNode" type="org.sonatype.nexus.repository.content.browse.internal.DatastoreBrowseNode">
    <id property="id" column="browse_node_id" />
    <result property="assetId" column="asset_id" />
    <result property="componentId" column="component_id" />
    <result property="format" column="format" />
    <result property="leaf" column="leaf" />
    <result property="name" column="name" />
    <result property="parentId" column="parent_id" />
    <result property="path" column="path" />
    <result property="repositoryId" column="repository_id"/>
  </resultMap>
</mapper>
